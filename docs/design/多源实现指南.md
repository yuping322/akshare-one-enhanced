# 多数据源实现指南

本指南说明如何为 akshare-one 添加新的数据源实现。

## 1. MultiSourceRouter 升级特性

### 1.1 增强的验证机制

```python
# 创建路由器时指定必需列和最小行数
router = MultiSourceRouter(
    providers=[
        ("source1", provider1),
        ("source2", provider2),
    ],
    required_columns=["timestamp", "open", "high", "low", "close", "volume"],
    min_rows=1,  # 至少需要1行数据
)
```

### 1.2 执行统计

```python
# 获取每个源的成功/失败统计
stats = router.get_stats()
# 输出: {
#   'source1': {'success': 10, 'failure': 2},
#   'source2': {'success': 5, 'failure': 0},
# }
```

### 1.3 详细结果追踪

```python
from akshare_one import ExecutionResult

# 使用 execute_with_result 获取详细信息
result = router.execute_with_result("get_hist_data")

if result.success:
    print(f"Data from: {result.source}")
    print(f"Attempts: {result.attempts}")
    df = result.data
else:
    print(f"Failed after {result.attempts} attempts")
    for source, error in result.error_details:
        print(f"  {source}: {error}")
```

## 2. 添加新数据源的步骤

### 2.1 基础架构设置

以添加腾讯财经（tencent）数据源为例：

**目录结构**:
```
src/akshare_one/modules/historical/
├── base.py                    # 基类 (HistoricalDataProvider)
├── eastmoney_direct.py        # 现有源
├── eastmoney.py               # 现有源
├── sina.py                    # 现有源
├── tencent.py                 # ✨ 新增文件
└── factory.py                 # 工厂类 (需要更新)
```

### 2.2 实现数据源适配器

**文件**: `modules/historical/tencent.py`

```python
"""Tencent Finance - Real-time Stock Historical Data Provider"""

from typing import Any
import pandas as pd
import requests
from .base import HistoricalDataProvider


class TencentHistorical(HistoricalDataProvider):
    """Tencent Finance historical stock data provider
    
    Features:
    - Fast real-time response
    - Minute-level data available
    - High stability
    """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.source_name = "tencent"

    def get_hist_data(self) -> pd.DataFrame:
        """Fetch historical data from Tencent Finance API
        
        API: http://qt.gtimg.cn/q=
        
        Tencent uses different stock code format:
        - Shanghai (6xxxxx) → 0xxxxxx (market code 0)
        - Shenzhen (0xxxxx/3xxxxx) → 1xxxxxx (market code 1)
        
        Returns:
            pd.DataFrame: Historical data with standardized columns
        """
        # Convert akshare-one format to Tencent format
        tencent_symbol = self._convert_symbol()
        
        try:
            # Construct API parameters
            url = "http://qt.gtimg.cn/q="
            
            # Make request
            params = {
                "u": "pinyin",
                "q": tencent_symbol,
            }
            r = requests.get(url, params=params, timeout=10)
            r.encoding = "utf-8"
            
            # Parse response and convert to standard format
            df = self._parse_response(r.text)
            
            if df.empty:
                raise ValueError(f"No data returned for symbol {self.symbol}")
            
            return df
            
        except Exception as e:
            raise ValueError(f"Failed to fetch Tencent data for {self.symbol}: {e}") from e

    def _convert_symbol(self) -> str:
        """Convert akshare-one format to Tencent format
        
        Examples:
            600000 → 0600000 (Shanghai A-stock)
            000001 → 1000001 (Shenzhen A-stock)
        """
        if self.symbol.startswith("6"):
            # Shanghai market
            return f"0{self.symbol}"
        else:
            # Shenzhen market
            return f"1{self.symbol}"

    def _parse_response(self, response_text: str) -> pd.DataFrame:
        """Parse Tencent API response and standardize format
        
        Tencent response format:
        v_scXXXXXX="2024-02-12 15:00:00~130.50~131.00~130.00~130.50~5000000~650000000000"
        
        Fields: date~open~high~low~close~volume~amount
        """
        # Extract data from response
        # This is a placeholder - actual parsing depends on Tencent's response format
        
        data = {
            "timestamp": [],
            "open": [],
            "high": [],
            "low": [],
            "close": [],
            "volume": [],
        }
        
        # Parse and populate data...
        # (implementation details depend on Tencent API response format)
        
        df = pd.DataFrame(data)
        return df
```

### 2.3 更新工厂类

**文件**: `modules/historical/factory.py`

```python
from .base import HistoricalDataProvider
from .eastmoney import EastMoneyHistorical
from .eastmoney_direct import EastMoneyDirectHistorical
from .sina import SinaHistorical
from .tencent import TencentHistorical  # ✨ 添加导入


class HistoricalDataFactory:
    """Factory class for creating historical data providers"""

    _providers = {
        "eastmoney": EastMoneyHistorical,
        "eastmoney_direct": EastMoneyDirectHistorical,
        "sina": SinaHistorical,
        "tencent": TencentHistorical,  # ✨ 注册新源
    }

    @classmethod
    def get_provider(cls, provider_name: str, **kwargs) -> HistoricalDataProvider:
        """Get a historical data provider by name
        
        Args:
            provider_name: Name of provider ('eastmoney', 'sina', 'tencent', ...)
            **kwargs: Arguments passed to provider constructor
            
        Returns:
            HistoricalDataProvider instance
            
        Raises:
            ValueError: If provider not found
        """
        provider_class = cls._providers.get(provider_name.lower())
        if not provider_class:
            available = ", ".join(cls._providers.keys())
            raise ValueError(
                f"Unknown provider: {provider_name}. "
                f"Available: {available}"
            )
        return provider_class(**kwargs)

    @classmethod
    def register_provider(cls, name: str, provider_class: type) -> None:
        """Dynamically register a new provider
        
        This allows runtime registration of custom providers:
        
        Example:
            class MyCustomProvider(HistoricalDataProvider):
                def get_hist_data(self):
                    ...
            
            HistoricalDataFactory.register_provider(
                "my_source",
                MyCustomProvider
            )
        """
        cls._providers[name.lower()] = provider_class
```

### 2.4 更新路由器配置

**文件**: `modules/multi_source.py`

在 `create_historical_router` 函数中更新默认源列表：

```python
def create_historical_router(
    symbol: str,
    interval: str = "day",
    # ... other parameters ...
    sources: list[str] | None = None,
    # ...
) -> MultiSourceRouter:
    """Create a router for historical data with multiple sources.
    
    ...
    """
    from .historical.factory import HistoricalDataFactory

    if sources is None:
        # ✨ Updated default sources - prioritize by reliability
        sources = [
            "eastmoney_direct",  # Primary: fastest, most complete
            "eastmoney",         # Secondary: same data, fallback
            "sina",              # Tertiary: stable backup
            "tencent",           # Quaternary: for specific needs
        ]
    
    # ... rest of function ...
```

## 3. 数据格式标准化

所有数据源必须返回统一格式的 DataFrame。

### 3.1 历史数据格式规范

```python
# 标准化的历史行情数据
standard_hist_df = pd.DataFrame({
    'timestamp': pd.DatetimeIndex([...]),  # or date strings YYYY-MM-DD
    'open': [float, ...],                  # 开盘价
    'high': [float, ...],                  # 最高价
    'low': [float, ...],                   # 最低价
    'close': [float, ...],                 # 收盘价
    'volume': [int, ...],                  # 成交量 (手)
    'amount': [float, ...],                # 成交额 (元) - 可选
})
```

### 3.2 实时数据格式规范

```python
standard_realtime_df = pd.DataFrame({
    'symbol': ["600000", ...],             # 股票代码
    'price': [float, ...],                 # 最新价
    'change': [float, ...],                # 涨跌额
    'pct_change': [float, ...],            # 涨跌幅 (%)
    'timestamp': [str/datetime, ...],      # 更新时间
    'volume': [int, ...],                  # 成交量 (手)
    'amount': [float, ...],                # 成交额 (元)
})
```

### 3.3 财务数据格式规范

```python
# 资产负债表格式
balance_sheet_df = pd.DataFrame({
    'report_date': [str, ...],             # 报告期 YYYY-MM-DD
    'total_assets': [float, ...],          # 资产总计
    'total_liabilities': [float, ...],     # 负债合计
    'equity': [float, ...],                # 股东权益
    # ... other standard fields ...
})
```

## 4. 测试新数据源

### 4.1 单元测试

**文件**: `tests/test_tencent.py`

```python
import pytest
import pandas as pd
from akshare_one.modules.historical.factory import HistoricalDataFactory


def test_tencent_provider_initialization():
    """Test provider can be instantiated"""
    provider = HistoricalDataFactory.get_provider(
        "tencent",
        symbol="600000",
        interval="day",
    )
    assert provider is not None
    assert provider.symbol == "600000"


def test_tencent_get_hist_data():
    """Test fetching historical data from Tencent"""
    provider = HistoricalDataFactory.get_provider(
        "tencent",
        symbol="600000",
        interval="day",
        start_date="2024-01-01",
        end_date="2024-01-31",
    )
    
    df = provider.get_hist_data()
    
    # Verify result structure
    assert isinstance(df, pd.DataFrame)
    assert not df.empty
    assert all(col in df.columns for col in [
        'timestamp', 'open', 'high', 'low', 'close', 'volume'
    ])


def test_multi_source_failover():
    """Test automatic failover between sources"""
    from akshare_one import create_historical_router
    
    router = create_historical_router(
        symbol="600000",
        interval="day",
        sources=["tencent", "sina", "eastmoney"],  # Tencent first
    )
    
    # Should fall back to next source if Tencent fails
    df = router.execute("get_hist_data")
    assert not df.empty
```

### 4.2 集成测试

```python
def test_all_sources_available():
    """Test all registered sources can be instantiated"""
    from akshare_one.modules.historical.factory import HistoricalDataFactory
    
    available_sources = [
        "eastmoney_direct",
        "eastmoney",
        "sina",
        "tencent",
    ]
    
    for source in available_sources:
        try:
            provider = HistoricalDataFactory.get_provider(
                source,
                symbol="600000",
                interval="day",
            )
            assert provider is not None
        except Exception as e:
            pytest.fail(f"Failed to initialize {source}: {e}")
```

## 5. 实现检查清单

为新数据源准备好后，使用此清单进行验证：

- [ ] 创建新的提供者类继承 Base Provider
- [ ] 实现所有必需的方法
- [ ] 数据格式完全符合标准
- [ ] 在 Factory 中注册提供者
- [ ] 更新路由器的默认源列表
- [ ] 编写单元测试
- [ ] 编写集成测试  
- [ ] 测试故障转移逻辑
- [ ] 文档化新增功能
- [ ] 更新示例代码

## 6. 错误处理最佳实践

```python
# ✅ 好的做法：提供详细的错误信息
try:
    response = requests.get(url, timeout=10)
    response.raise_for_status()
except requests.Timeout:
    raise ValueError(f"Timeout fetching {self.source_name} data for {self.symbol}")
except requests.HTTPError as e:
    raise ValueError(f"HTTP {e.response.status_code} from {self.source_name}")

# ❌ 避免：generic exception
except Exception:
    raise ValueError("Data fetch failed")  # 信息不足

# ❌ 避免：静默失败
result = parse_json(response)  # 如果解析失败将崩溃
```

## 7. 性能优化建议

### 7.1 缓存策略

使用现有的 `@smart_cache` 装饰器：

```python
from akshare_one.modules.cache import smart_cache

class TencentHistorical(HistoricalDataProvider):
    @smart_cache(
        realtime_key="hist_data_cache",
        daily_key="hist_daily_cache",
        key=lambda self: f"tencent_hist_{self.symbol}_{self.interval}",
    )
    def get_hist_data(self) -> pd.DataFrame:
        # Implementation...
```

### 7.2 连接复用

```python
# 创建会话以复用连接
import requests

class TencentHistorical(HistoricalDataProvider):
    _session = requests.Session()
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # 可选：配置session
        self._session.timeout = 10
        self._session.headers.update({
            'User-Agent': 'Mozilla/5.0...'
        })
    
    def get_hist_data(self):
        # 使用会话而非单独请求
        r = self._session.get(url)
```

---

完成日期: 2026-02-12
